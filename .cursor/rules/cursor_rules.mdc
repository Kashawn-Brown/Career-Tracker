---
description: Guidelines for creating and maintaining Cursor rules to ensure consistency and effectiveness.
globs: .cursor/rules/*.mdc
alwaysApply: true
---

- **Required Rule Structure:**
  ```markdown
  ---
  description: Clear, one-line description of what the rule enforces
  globs: path/to/files/*.ext, other/path/**/*
  alwaysApply: boolean
  ---

  - **Main Points in Bold**
    - Sub-points with details
    - Examples and explanations
  ```

- **File References:**
  - Use `[filename](mdc:path/to/file)` ([filename](mdc:filename)) to reference files
  - Example: [prisma.mdc](mdc:.cursor/rules/prisma.mdc) for rule references
  - Example: [schema.prisma](mdc:prisma/schema.prisma) for code references

- **Code Examples:**
  - Use language-specific code blocks
  ```typescript
  // ✅ DO: Show good examples
  const goodExample = true;
  
  // ❌ DON'T: Show anti-patterns
  const badExample = false;
  ```

- **Rule Content Guidelines:**
  - Start with high-level overview
  - Include specific, actionable requirements
  - Show examples of correct implementation
  - Reference existing code when possible
  - Keep rules DRY by referencing other rules

- **Rule Maintenance:**
  - Update rules when new patterns emerge
  - Add examples from actual codebase
  - Remove outdated patterns
  - Cross-reference related rules

- **Best Practices:**
  - Use bullet points for clarity
  - Keep descriptions concise
  - Include both DO and DON'T examples
  - Reference actual code over theoretical examples
  - Use consistent formatting across rules 

  # Cursor Rules for AI Suggestions and Code Quality

## GENERAL CONVENTIONS

- Always use modern, non-deprecated web APIs, libraries, and language features. Avoid legacy code, outdated syntax, or deprecated practices.
- Follow current best practices for the given language, framework, or environment.
- Use semantic HTML, modern CSS techniques (Flexbox, Grid), and progressive enhancement where appropriate.
- Avoid jQuery, unless explicitly requested.
- Prefer modern module systems (ESM over CommonJS, imports over require).
- Use async/await and promises instead of callbacks.
- Avoid magic numbers or hardcoded strings; use constants or config files.
- Include clear and meaningful comments explaining why something is done, not just what.
- For niche, novel, or complex concepts, prefer longer, explanatory comments that clarify the reasoning behind the code, not just what it does.
- Always handle errors gracefully, especially in async code.

## NAMING & STRUCTURE

- Use descriptive and consistent naming: camelCase for variables/functions, PascalCase for classes/components.
- Do not abbreviate unless industry-standard (e.g., `req`, `res` for request/response).
- Name files according to their purpose, not vague terms like `utils.js` or `stuff.ts`.

## CODE ORGANIZATION

- Modularize code: split logic into functions and keep each file focused on a single responsibility.
- For games and apps, maintain a clean folder structure:
  - `components/` for reusable UI components
  - `services/` for API or data-fetching logic
  - `utils/` or `helpers/` for general-purpose utilities
  - `game/` for game logic modules (e.g., `physics`, `input`, `state`, `engine`)
  - `assets/` for static files like images or sounds
- Use `index.js` or `index.ts` files to re-export when it improves import clarity.

## JAVASCRIPT/WEB-SPECIFIC

- Use `const` by default. Use `let` only when mutation is required. Never use `var`.
- Use arrow functions unless a traditional function is required (e.g., for `this` binding).
- Use TypeScript when possible or JSDoc types in JavaScript for clarity and safety.
- Avoid inline styles and prefer CSS modules, styled-components, or scoped CSS for styling.
- Always ensure accessibility (e.g., use `aria-` attributes and correct HTML roles).

## GAME DEVELOPMENT SPECIFIC

- Keep game logic modular and separated from rendering/UI code.
- Game state should be clearly separated and updated via pure functions if possible.
- Event handling should be decoupled from game rules (e.g., use an event bus or observer pattern).
- Frame updates (animation/game loop) should be optimized and avoid memory leaks or unnecessary re-renders.
- Input handling should be abstracted so it’s easy to switch from keyboard to touch or gamepad.

## DO NOT DO

- Do not use deprecated tags like `<center>`, `<font>`, or old-style table layouts.
- Do not mix logic and UI excessively.
- Do not generate large files with multiple responsibilities.
- Do not write deeply nested code (more than 3 levels).
- Do not use global variables unless absolutely necessary.

## STYLE & CONSISTENCY

- Always trim trailing whitespace.
- Use Unix-style line endings (LF).
- Files should end with a newline.
- Keep functions short and readable (< 50 lines ideally).
- Use consistent indentation (2 spaces unless otherwise specified).
